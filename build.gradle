import static groovy.json.JsonOutput.prettyPrint
import static groovy.json.JsonOutput.toJson
import groovy.json.JsonSlurper
import java.io.File
import com.bmuschko.gradle.docker.tasks.image.Dockerfile
import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.bmuschko.gradle.docker.tasks.image.DockerPushImage
import com.bmuschko.gradle.docker.tasks.image.DockerPullImage

buildscript {
    repositories {
        mavenCentral()
        jcenter()
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:1.5.1.RELEASE")
        classpath "com.bmuschko:gradle-docker-plugin:3.0.5"
        classpath "org.hidetake:gradle-ssh-plugin:2.8.0"
    }
}

apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'org.springframework.boot'
apply plugin: 'com.bmuschko.docker-remote-api'
apply plugin: 'org.hidetake.ssh'


ext.systemProperties= System.properties

def stackName = 'TestStack'
def org = dockerOrg
def awsaccessKey = '--accesskey='+ awskey
def secretKey = '--secret='+ awssecret
def parameters = '--parameters='+ stackparams
def stack = '--stackname='+stackName
def rbacktimeout = '--rollbacktimeout='+ rtimeout
def waittime = '--waittime='+ looptime
def bucketname = '--bucketname='+s3bucketname
def filename = '--filename=' +s3filename
def fileloc = '--fileloc='+s3filelocation

def jsonSlurper = new JsonSlurper()

jar {
    baseName = imageName
    version =  imageVersion
}

repositories {
   mavenCentral()
}

sourceCompatibility = 1.8
targetCompatibility = 1.8

dependencies {
    compile("org.springframework.boot:spring-boot-starter-web")
    testCompile("org.springframework.boot:spring-boot-starter-test")
}

docker {
    registryCredentials {
        url = 'https://index.docker.io/v1'
        username = dockerUser
        password = dockerPassword
        email = dockerEmail
    }
}

task buildImage(type: DockerBuildImage) {
    dockerFile = new File('./docker/Dockerfile')
    inputDir = dockerFile.parentFile
    tag = org + "/" + jar.baseName
    buildArgs = ['appjar': jar.baseName+'-'+jar.version+'.jar']
    
    doFirst {
         copy {
	     from jar
	     into './docker/'
	   }
  	}
}

task pushImage(type: DockerPushImage) {
     imageName = org + "/" + jar.baseName
}


remotes {
  docker {
    user = awsuser
    identity = file(awspublickey)
  }
}

def script =scriptloc+'cloudformation.py'

task createAWSStack(type:Exec) {
   workingDir './template/'
   executable = "python"
   args = [script, awsaccessKey, secretKey, parameters, stack, rbacktimeout, waittime, bucketname,filename, fileloc]
    
   standardOutput = new ByteArrayOutputStream()
	 doLast {
		ext.stackOutput = standardOutput.toString()
		println "Populating values :" +stackOutput
	    def object = jsonSlurper.parseText(stackOutput)
	    ext.sshHost = object.ServerIp
	    createAWSStack.ext.sshHost = object.ServerIP
	    println "Service Ip is :" +createAWSStack.ext.sshHost
	    sleep(600 * 1000)
	 }
}

def command = 'sudo docker run -d -p 80:8080 ' + org + "/" + jar.baseName

ssh.settings {
  knownHosts = allowAnyHosts
}


//dependsOn: createAWSStack
task runDockerImage (dependsOn: createAWSStack) {
   doFirst {
      remotes.docker.host = createAWSStack.sshHost
      //sleep(120 * 1000)
   }
   doLast {
	   ssh.run {
	     session(remotes.docker) {
	      // Execute a command
	      def result = execute command
	      println result
	     }
	  }
  }
}

//genericTask.mustRunAfter createAWSStack
